/*
 * scheduler.c
 *
 *  Created on: Nov 24, 2022
 *      Author: Linh
 */

#include "scheduler.h"

sTasks SCH_tasks_G[SCH_MAX_TASKS];
uint8_t current_index_task = 0;
int count = 0;

void SCH_Init(void) {
	current_index_task = 0;
}

void SCH_Add_Task(void (*pFunction)(), uint32_t DELAY, uint32_t PERIOD) {
	if (count == 0) {
		// Add task at the index = 0 if the scheduler is empty
		SCH_tasks_G[0].pTask = pFunction;
		SCH_tasks_G[0].Delay = DELAY;
		SCH_tasks_G[0].Period = PERIOD;
		SCH_tasks_G[0].RunMe = 0;
		count++;
	} else if (count > 0) {
		// Find satisfying locations to add new task
		while ((current_index_task < count) && count < SCH_MAX_TASKS) {
			if (SCH_tasks_G[current_index_task].Delay > DELAY) {
				for (int i = count; i > current_index_task; i--)
				{
					// Shift tasks
					SCH_tasks_G [i ] = SCH_tasks_G [i -1];
				}
				SCH_tasks_G[current_index_task].pTask = pFunction;
				SCH_tasks_G[current_index_task].Delay = DELAY;
				SCH_tasks_G[current_index_task].Period = PERIOD;
				SCH_tasks_G[current_index_task].RunMe = 0;
				count++;
				for (int j = current_index_task + 1; j < count; j++) {
					SCH_tasks_G[j].Delay -= DELAY;
				}
				break;
			} else {
				DELAY -= SCH_tasks_G[current_index_task].Delay;
			}
			current_index_task++;
		}
		// If we â€™re in the last of scheduler and scheduler is not full = > Insert new task here
		if (Index == count && (count + 1 < SCH_MAX_TASKS)) {
			SCH_tasks_G[current_index_task].pTask = pFunction;
			SCH_tasks_G[current_index_task].Delay = DELAY;
			SCH_tasks_G[current_index_task].Period = PERIOD;
			SCH_tasks_G[current_index_task].RunMe = 0;
			count++;
		}
	}
	// Return position of task (to allow later deletion )
	return current_index_task;
}

void SCH_Update(void) {
	for (int i = 0; i < current_index_task; i++) {
		if (SCH_tasks_G[i].Delay > 0) {
			SCH_tasks_G[i].Delay--;
		} else {
			SCH_tasks_G[i].Delay = SCH_tasks_G[i].Period;
			SCH_tasks_G[i].RunMe += 1;
		}
	}
}

void SCH_Dispatch_Tasks(void) {
	for (int i = 0; i < current_index_task; i++) {
		if (SCH_tasks_G[i].RunMe > 0) {
			SCH_tasks_G[i].RunMe--;
			(*SCH_tasks_G[i].pTask)();
		}

		if (SCH_tasks_G[i].Period == 0) {
			SCH_Delete_Task(i);
		}
	}
}

unsigned char SCH_Delete_Task(const int TASK_INDEX) {
	unsigned char Return_code = 0;
	SCH_tasks_G[TASK_INDEX].pTask = 0x0000;
	SCH_tasks_G[TASK_INDEX].Delay = 0;
	SCH_tasks_G[TASK_INDEX].Period = 0;
	SCH_tasks_G[TASK_INDEX].RunMe = 0;
	return Return_code; // return status
}
