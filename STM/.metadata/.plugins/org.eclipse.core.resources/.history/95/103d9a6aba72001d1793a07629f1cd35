/*
 * scheduler.c
 *
 *  Created on: Nov 24, 2022
 *      Author: Linh
 */

#include "scheduler.h"

sTasks SCH_tasks_G[SCH_MAX_TASKS];
uint8_t current_index_task = 0;
int count = 0;

void SCH_Init(void) {
	current_index_task = 0;
}

unsigned char SCH_Add_Task (void (* pFunction )() , unsigned int DELAY, unsigned int PERIOD) {
	if (count == 0) {
		// Add task at the index = 0 if the scheduler is empty
		SCH_tasks_G[0].pTask = pFunction;
		SCH_tasks_G[0].Delay = DELAY;
		SCH_tasks_G[0].Period = PERIOD;
		SCH_tasks_G[0].RunMe = 0;
		count++;
	} else if (count > 0) {
		// Find satisfying locations to add new task
		while ((current_index_task < count) && count < SCH_MAX_TASKS) {
			if (SCH_tasks_G[current_index_task].Delay > DELAY) {
				for (int i = count; i > current_index_task; i--) {
					// Shift tasks
					SCH_tasks_G[i] = SCH_tasks_G[i - 1];
				}
				SCH_tasks_G[current_index_task].pTask = pFunction;
				SCH_tasks_G[current_index_task].Delay = DELAY;
				SCH_tasks_G[current_index_task].Period = PERIOD;
				SCH_tasks_G[current_index_task].RunMe = 0;
				count++;
				for (int j = current_index_task + 1; j < count; j++) {
					SCH_tasks_G[j].Delay -= DELAY;
				}
				break;
			} else {
				DELAY -= SCH_tasks_G[current_index_task].Delay;
			}
			current_index_task++;
		}
		// If we ’re in the last of scheduler and scheduler is not full = > Insert new task here
		if (current_index_task == count && (count + 1 < SCH_MAX_TASKS)) {
			SCH_tasks_G[current_index_task].pTask = pFunction;
			SCH_tasks_G[current_index_task].Delay = DELAY;
			SCH_tasks_G[current_index_task].Period = PERIOD;
			SCH_tasks_G[current_index_task].RunMe = 0;
			count++;
		}
	}
}

void SCH_Update(void) {
	// Check if there is a task at this location
	if (SCH_tasks_G[0].pTask) {
		if (SCH_tasks_G[0].Delay == 0) {
			// The task is due to run
			// Inc. the ’RunMe ’ flag
			SCH_tasks_G[0].RunMe += 1;
			if (SCH_tasks_G[0].Period) {
				// Schedule periodic tasks to run again
				SCH_tasks_G[0].Delay = SCH_tasks_G[0].Period;
			}
		} else {
			// Not yet ready to run : just decrement the delay
			SCH_tasks_G[0].Delay -= 1;
		}
	}
}

void SCH_Dispatch_Tasks(void) {
	// Dispatches ( runs ) the next task (if one is ready )
	if (SCH_tasks_G[0].RunMe > 0) {
		(*SCH_tasks_G[0].pTask)(); // Run the task
		SCH_tasks_G[0].RunMe -= 1; // Reset / reduce RunMe flag
		// Periodic tasks will automatically run again
		// - if this is a ’one shot ’ task , remove it from the array
		if (SCH_tasks_G[0].Period == 0) {
			SCH_Delete_Task(0);
		} else {
			sTask temp = SCH_tasks_G[0];
			SCH_Delete_Task(0);
			SCH_Shift_Task(0);
			SCH_Add_Task(temp.pTask, temp.Delay, temp.Period);
		}
	}
}

unsigned char SCH_Delete_Task(const int TASK_INDEX) {
	unsigned char Return_code = 0;
	SCH_tasks_G[TASK_INDEX].pTask = 0x0000;
	SCH_tasks_G[TASK_INDEX].Delay = 0;
	SCH_tasks_G[TASK_INDEX].Period = 0;
	SCH_tasks_G[TASK_INDEX].RunMe = 0;
	return Return_code; // return status
}

void SCH_Shift_Task(const int TASK_INDEX) {
	if (TASK_INDEX != count - 1) {
		for (int i = TASK_INDEX; i < count - 1; i++) {
			SCH_tasks_G[i] = SCH_tasks_G[i + 1];
		}
		SCH_tasks_G[count - 1].pTask = 0x0000;
		SCH_tasks_G[count - 1].Delay = 0;
		SCH_tasks_G[count - 1].Period = 0;
		SCH_tasks_G[count - 1].RunMe = 0;
	}
	count--;
}
